// Code generated by protoc-gen-go.
// source: mysqlx_crud.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// DataModel to use for filters, names, ...
type DataModel int32

const (
	DataModel_DOCUMENT DataModel = 1
	DataModel_TABLE    DataModel = 2
)

var DataModel_name = map[int32]string{
	1: "DOCUMENT",
	2: "TABLE",
}
var DataModel_value = map[string]int32{
	"DOCUMENT": 1,
	"TABLE":    2,
}

func (x DataModel) Enum() *DataModel {
	p := new(DataModel)
	*p = x
	return p
}
func (x DataModel) String() string {
	return proto1.EnumName(DataModel_name, int32(x))
}
func (x *DataModel) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(DataModel_value, data, "DataModel")
	if err != nil {
		return err
	}
	*x = DataModel(value)
	return nil
}
func (DataModel) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type Order_Direction int32

const (
	Order_ASC  Order_Direction = 1
	Order_DESC Order_Direction = 2
)

var Order_Direction_name = map[int32]string{
	1: "ASC",
	2: "DESC",
}
var Order_Direction_value = map[string]int32{
	"ASC":  1,
	"DESC": 2,
}

func (x Order_Direction) Enum() *Order_Direction {
	p := new(Order_Direction)
	*p = x
	return p
}
func (x Order_Direction) String() string {
	return proto1.EnumName(Order_Direction_name, int32(x))
}
func (x *Order_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(Order_Direction_value, data, "Order_Direction")
	if err != nil {
		return err
	}
	*x = Order_Direction(value)
	return nil
}
func (Order_Direction) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 0} }

type UpdateOperation_UpdateType int32

const (
	UpdateOperation_SET          UpdateOperation_UpdateType = 1
	UpdateOperation_ITEM_REMOVE  UpdateOperation_UpdateType = 2
	UpdateOperation_ITEM_SET     UpdateOperation_UpdateType = 3
	UpdateOperation_ITEM_REPLACE UpdateOperation_UpdateType = 4
	UpdateOperation_ITEM_MERGE   UpdateOperation_UpdateType = 5
	UpdateOperation_ARRAY_INSERT UpdateOperation_UpdateType = 6
	UpdateOperation_ARRAY_APPEND UpdateOperation_UpdateType = 7
)

var UpdateOperation_UpdateType_name = map[int32]string{
	1: "SET",
	2: "ITEM_REMOVE",
	3: "ITEM_SET",
	4: "ITEM_REPLACE",
	5: "ITEM_MERGE",
	6: "ARRAY_INSERT",
	7: "ARRAY_APPEND",
}
var UpdateOperation_UpdateType_value = map[string]int32{
	"SET":          1,
	"ITEM_REMOVE":  2,
	"ITEM_SET":     3,
	"ITEM_REPLACE": 4,
	"ITEM_MERGE":   5,
	"ARRAY_INSERT": 6,
	"ARRAY_APPEND": 7,
}

func (x UpdateOperation_UpdateType) Enum() *UpdateOperation_UpdateType {
	p := new(UpdateOperation_UpdateType)
	*p = x
	return p
}
func (x UpdateOperation_UpdateType) String() string {
	return proto1.EnumName(UpdateOperation_UpdateType_name, int32(x))
}
func (x *UpdateOperation_UpdateType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(UpdateOperation_UpdateType_value, data, "UpdateOperation_UpdateType")
	if err != nil {
		return err
	}
	*x = UpdateOperation_UpdateType(value)
	return nil
}
func (UpdateOperation_UpdateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{5, 0}
}

// column definition
type Column struct {
	Name             *string             `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Alias            *string             `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	DocumentPath     []*DocumentPathItem `protobuf:"bytes,3,rep,name=document_path" json:"document_path,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (m *Column) String() string            { return proto1.CompactTextString(m) }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *Column) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Column) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

func (m *Column) GetDocumentPath() []*DocumentPathItem {
	if m != nil {
		return m.DocumentPath
	}
	return nil
}

// a projection
//
// :param source: the expression identifying an element from the source data
//                which can include a column identifier or any expression
// :param alias: optional alias. Required for DOCUMENTs (clients may use
//              the source string as default)
type Projection struct {
	Source           *Expr   `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Alias            *string `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Projection) Reset()                    { *m = Projection{} }
func (m *Projection) String() string            { return proto1.CompactTextString(m) }
func (*Projection) ProtoMessage()               {}
func (*Projection) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *Projection) GetSource() *Expr {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Projection) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

// collection
type Collection struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Schema           *string `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Collection) Reset()                    { *m = Collection{} }
func (m *Collection) String() string            { return proto1.CompactTextString(m) }
func (*Collection) ProtoMessage()               {}
func (*Collection) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *Collection) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Collection) GetSchema() string {
	if m != nil && m.Schema != nil {
		return *m.Schema
	}
	return ""
}

// limit
//
// :param row_count: maximum rows to filter
// :param offset: maximum rows to skip before applying the row_count
type Limit struct {
	RowCount         *uint64 `protobuf:"varint,1,req,name=row_count" json:"row_count,omitempty"`
	Offset           *uint64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Limit) Reset()                    { *m = Limit{} }
func (m *Limit) String() string            { return proto1.CompactTextString(m) }
func (*Limit) ProtoMessage()               {}
func (*Limit) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Limit) GetRowCount() uint64 {
	if m != nil && m.RowCount != nil {
		return *m.RowCount
	}
	return 0
}

func (m *Limit) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

// sort order
type Order struct {
	Expr             *Expr            `protobuf:"bytes,1,req,name=expr" json:"expr,omitempty"`
	Direction        *Order_Direction `protobuf:"varint,2,opt,name=direction,enum=Mysqlx.Crud.Order_Direction,def=1" json:"direction,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto1.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

const Default_Order_Direction Order_Direction = Order_ASC

func (m *Order) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Order) GetDirection() Order_Direction {
	if m != nil && m.Direction != nil {
		return *m.Direction
	}
	return Default_Order_Direction
}

// update operations
//
// :param source: specification of the value to be updated
//      if data_model is TABLE, a column name may be specified and also a document path, if the column has type JSON
//      if data_model is DOCUMENT, only document paths are allowed
//      in both cases, schema and table must be not set
// :param operation: the type of operation to be performed
// :param value: an expression to be computed as the new value for the operation
type UpdateOperation struct {
	Source           *ColumnIdentifier           `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Operation        *UpdateOperation_UpdateType `protobuf:"varint,2,req,name=operation,enum=Mysqlx.Crud.UpdateOperation_UpdateType" json:"operation,omitempty"`
	Value            *Expr                       `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *UpdateOperation) Reset()                    { *m = UpdateOperation{} }
func (m *UpdateOperation) String() string            { return proto1.CompactTextString(m) }
func (*UpdateOperation) ProtoMessage()               {}
func (*UpdateOperation) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *UpdateOperation) GetSource() *ColumnIdentifier {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *UpdateOperation) GetOperation() UpdateOperation_UpdateType {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return UpdateOperation_SET
}

func (m *UpdateOperation) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

// Find Documents/Rows in a Collection/Table
//
// .. uml::
//
//   client -> server: Find
//   ... one or more Resultset ...
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: list of column projections that shall be returned
// :param args: values for parameters used in filter expression
// :param criteria: filter criteria
// :param limit: numbers of rows that shall be skipped and returned
// :param order: sort-order in which the rows/document shall be returned in
// :param grouping: column expression list for aggregation (GROUP BY)
// :param grouping_criteria: filter criteria for aggregated groups
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Find struct {
	Collection       *Collection   `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel    `protobuf:"varint,3,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection       []*Projection `protobuf:"bytes,4,rep,name=projection" json:"projection,omitempty"`
	Criteria         *Expr         `protobuf:"bytes,5,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Scalar     `protobuf:"bytes,11,rep,name=args" json:"args,omitempty"`
	Limit            *Limit        `protobuf:"bytes,6,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order      `protobuf:"bytes,7,rep,name=order" json:"order,omitempty"`
	Grouping         []*Expr       `protobuf:"bytes,8,rep,name=grouping" json:"grouping,omitempty"`
	GroupingCriteria *Expr         `protobuf:"bytes,9,opt,name=grouping_criteria" json:"grouping_criteria,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Find) Reset()                    { *m = Find{} }
func (m *Find) String() string            { return proto1.CompactTextString(m) }
func (*Find) ProtoMessage()               {}
func (*Find) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *Find) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Find) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Find) GetProjection() []*Projection {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Find) GetCriteria() *Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Find) GetArgs() []*Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Find) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Find) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Find) GetGrouping() []*Expr {
	if m != nil {
		return m.Grouping
	}
	return nil
}

func (m *Find) GetGroupingCriteria() *Expr {
	if m != nil {
		return m.GroupingCriteria
	}
	return nil
}

// Insert documents/rows into a collection/table
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: name of the columns to insert data into (empty if data_model is DOCUMENT)
// :param row: set of rows to insert into the collection/table (a single expression with a JSON document literal or an OBJECT expression)
// :param args: values for parameters used in row expressions
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Insert struct {
	Collection       *Collection        `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel         `protobuf:"varint,2,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection       []*Column          `protobuf:"bytes,3,rep,name=projection" json:"projection,omitempty"`
	Row              []*Insert_TypedRow `protobuf:"bytes,4,rep,name=row" json:"row,omitempty"`
	Args             []*Scalar          `protobuf:"bytes,5,rep,name=args" json:"args,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Insert) Reset()                    { *m = Insert{} }
func (m *Insert) String() string            { return proto1.CompactTextString(m) }
func (*Insert) ProtoMessage()               {}
func (*Insert) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *Insert) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Insert) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Insert) GetProjection() []*Column {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Insert) GetRow() []*Insert_TypedRow {
	if m != nil {
		return m.Row
	}
	return nil
}

func (m *Insert) GetArgs() []*Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

type Insert_TypedRow struct {
	Field            []*Expr `protobuf:"bytes,1,rep,name=field" json:"field,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Insert_TypedRow) Reset()                    { *m = Insert_TypedRow{} }
func (m *Insert_TypedRow) String() string            { return proto1.CompactTextString(m) }
func (*Insert_TypedRow) ProtoMessage()               {}
func (*Insert_TypedRow) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7, 0} }

func (m *Insert_TypedRow) GetField() []*Expr {
	if m != nil {
		return m.Field
	}
	return nil
}

// Update documents/rows in a collection/table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match
// :param order: specifies order of matched rows
// :param operation: list of operations to be applied. Valid operations will depend on the data_model.
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Update struct {
	Collection       *Collection        `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel         `protobuf:"varint,3,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria         *Expr              `protobuf:"bytes,4,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Scalar          `protobuf:"bytes,8,rep,name=args" json:"args,omitempty"`
	Limit            *Limit             `protobuf:"bytes,5,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order           `protobuf:"bytes,6,rep,name=order" json:"order,omitempty"`
	Operation        []*UpdateOperation `protobuf:"bytes,7,rep,name=operation" json:"operation,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto1.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *Update) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Update) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Update) GetCriteria() *Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Update) GetArgs() []*Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Update) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Update) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Update) GetOperation() []*UpdateOperation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Delete documents/rows from a Collection/Table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match
// :param order: specifies order of matched rows
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Delete struct {
	Collection       *Collection `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel  `protobuf:"varint,2,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria         *Expr       `protobuf:"bytes,3,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Scalar   `protobuf:"bytes,6,rep,name=args" json:"args,omitempty"`
	Limit            *Limit      `protobuf:"bytes,4,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order    `protobuf:"bytes,5,rep,name=order" json:"order,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Delete) Reset()                    { *m = Delete{} }
func (m *Delete) String() string            { return proto1.CompactTextString(m) }
func (*Delete) ProtoMessage()               {}
func (*Delete) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *Delete) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Delete) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Delete) GetCriteria() *Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Delete) GetArgs() []*Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Delete) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Delete) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func init() {
	proto1.RegisterType((*Column)(nil), "Mysqlx.Crud.Column")
	proto1.RegisterType((*Projection)(nil), "Mysqlx.Crud.Projection")
	proto1.RegisterType((*Collection)(nil), "Mysqlx.Crud.Collection")
	proto1.RegisterType((*Limit)(nil), "Mysqlx.Crud.Limit")
	proto1.RegisterType((*Order)(nil), "Mysqlx.Crud.Order")
	proto1.RegisterType((*UpdateOperation)(nil), "Mysqlx.Crud.UpdateOperation")
	proto1.RegisterType((*Find)(nil), "Mysqlx.Crud.Find")
	proto1.RegisterType((*Insert)(nil), "Mysqlx.Crud.Insert")
	proto1.RegisterType((*Insert_TypedRow)(nil), "Mysqlx.Crud.Insert.TypedRow")
	proto1.RegisterType((*Update)(nil), "Mysqlx.Crud.Update")
	proto1.RegisterType((*Delete)(nil), "Mysqlx.Crud.Delete")
	proto1.RegisterEnum("Mysqlx.Crud.DataModel", DataModel_name, DataModel_value)
	proto1.RegisterEnum("Mysqlx.Crud.Order_Direction", Order_Direction_name, Order_Direction_value)
	proto1.RegisterEnum("Mysqlx.Crud.UpdateOperation_UpdateType", UpdateOperation_UpdateType_name, UpdateOperation_UpdateType_value)
}

func init() { proto1.RegisterFile("mysqlx_crud.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 789 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x95, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xc7, 0xe5, 0xcf, 0xc4, 0x27, 0xdd, 0xae, 0x3b, 0x48, 0x8b, 0x55, 0x2d, 0x90, 0x9a, 0x8f,
	0x0d, 0x65, 0x31, 0x52, 0xb4, 0x57, 0x7b, 0x81, 0x94, 0x8d, 0x0d, 0x8a, 0xd4, 0xb4, 0x51, 0x92,
	0x45, 0x02, 0x2e, 0xa2, 0xc1, 0x9e, 0xb4, 0x5e, 0xd9, 0x1e, 0x33, 0x1e, 0xd3, 0x96, 0x0b, 0x5e,
	0x80, 0x37, 0xe0, 0x9e, 0x17, 0x44, 0x3c, 0x00, 0x9a, 0x71, 0xe2, 0xc6, 0xd9, 0x66, 0x53, 0x24,
	0xb8, 0x89, 0xe2, 0x33, 0xff, 0x39, 0x73, 0xce, 0x6f, 0xfe, 0x3e, 0x86, 0xa3, 0xf4, 0xb6, 0xf8,
	0x39, 0xb9, 0x59, 0x84, 0xac, 0x8c, 0xbc, 0x9c, 0x51, 0x4e, 0x51, 0x67, 0x2c, 0x43, 0xde, 0x90,
	0x95, 0xd1, 0xf1, 0x7a, 0x9d, 0xdc, 0xe4, 0xac, 0x5a, 0x3f, 0x7e, 0xb2, 0x0a, 0x45, 0x98, 0x63,
	0x7e, 0x9b, 0x93, 0xa2, 0x8a, 0xbb, 0x3f, 0x82, 0x39, 0xa4, 0x49, 0x99, 0x66, 0xe8, 0x00, 0xf4,
	0x0c, 0xa7, 0xc4, 0x51, 0xba, 0x4a, 0xcf, 0x42, 0x8f, 0xc0, 0xc0, 0x49, 0x8c, 0x0b, 0x47, 0x95,
	0x8f, 0x2f, 0xe0, 0x51, 0x44, 0xc3, 0x32, 0x25, 0x19, 0x5f, 0xe4, 0x98, 0x5f, 0x39, 0x5a, 0x57,
	0xeb, 0x75, 0xfa, 0x1f, 0x78, 0xab, 0x63, 0x03, 0x71, 0x92, 0xbf, 0x52, 0x4c, 0x30, 0xbf, 0x1a,
	0x71, 0x92, 0xba, 0x5f, 0x03, 0x4c, 0x18, 0x7d, 0x43, 0x42, 0x1e, 0xd3, 0x0c, 0x9d, 0x80, 0x59,
	0xd0, 0x92, 0x85, 0xe2, 0x08, 0xb5, 0xd7, 0xe9, 0x1f, 0x35, 0x36, 0x8b, 0x9f, 0xad, 0x53, 0xdd,
	0x53, 0x80, 0x21, 0x4d, 0x92, 0xd5, 0xfe, 0xbb, 0x02, 0xd5, 0x9e, 0x85, 0x0e, 0xc1, 0x2c, 0xc2,
	0x2b, 0x92, 0xe2, 0x5a, 0x6b, 0x9c, 0xc5, 0x69, 0xcc, 0xd1, 0x11, 0x58, 0x8c, 0x5e, 0x2f, 0x42,
	0x5a, 0x66, 0x5c, 0x6a, 0x75, 0xa1, 0xa5, 0xcb, 0x65, 0x41, 0xb8, 0xd4, 0xea, 0xee, 0x6f, 0x60,
	0x5c, 0xb0, 0x88, 0x30, 0xf4, 0x11, 0xe8, 0x82, 0xd1, 0xee, 0x82, 0x5e, 0x80, 0x15, 0xc5, 0xac,
	0x2a, 0x40, 0x6e, 0x3e, 0xec, 0x3f, 0xf5, 0x36, 0x50, 0x7b, 0x32, 0x8f, 0xe7, 0xaf, 0x35, 0x2f,
	0xb5, 0xc1, 0x6c, 0xe8, 0x7e, 0x08, 0x56, 0x1d, 0x41, 0x2d, 0x10, 0x31, 0x5b, 0x41, 0x6d, 0xd0,
	0xfd, 0x60, 0x36, 0xb4, 0x55, 0xf7, 0x0f, 0x15, 0x1e, 0xbf, 0xce, 0x23, 0xcc, 0xc9, 0x45, 0x4e,
	0x18, 0x96, 0xb2, 0x2f, 0xb7, 0xe8, 0x34, 0xd1, 0x56, 0x77, 0x34, 0x8a, 0x48, 0xc6, 0xe3, 0x65,
	0x4c, 0x18, 0x7a, 0x09, 0x16, 0x5d, 0xef, 0x75, 0xd4, 0xae, 0xda, 0x3b, 0xec, 0x3f, 0x6b, 0x14,
	0xb6, 0x95, 0x7f, 0xf5, 0x3c, 0xbf, 0xcd, 0x09, 0xea, 0x82, 0xf1, 0x0b, 0x4e, 0x4a, 0xe2, 0x68,
	0x5d, 0xe5, 0xde, 0xb6, 0xdd, 0x5f, 0x01, 0x36, 0xf4, 0x2d, 0xd0, 0x66, 0xc1, 0xdc, 0x56, 0xd0,
	0x63, 0xe8, 0x8c, 0xe6, 0xc1, 0x78, 0x31, 0x0d, 0xc6, 0x17, 0xdf, 0x05, 0xb6, 0x8a, 0x0e, 0xa0,
	0x2d, 0x03, 0x62, 0x59, 0x43, 0x36, 0x1c, 0xac, 0x96, 0x27, 0x67, 0x83, 0x61, 0x60, 0x0b, 0xf0,
	0x20, 0x23, 0xe3, 0x60, 0xfa, 0x6d, 0x60, 0x1b, 0x42, 0x31, 0x98, 0x4e, 0x07, 0xdf, 0x2f, 0x46,
	0xe7, 0xb3, 0x60, 0x3a, 0xb7, 0xcd, 0xbb, 0xc8, 0x60, 0x32, 0x09, 0xce, 0x7d, 0xbb, 0xe5, 0xfe,
	0xa5, 0x82, 0xfe, 0x4d, 0x9c, 0x45, 0xe8, 0x0b, 0x80, 0xb0, 0xbe, 0x7d, 0xd9, 0x63, 0xa7, 0xff,
	0x7e, 0xa3, 0xc7, 0x0d, 0x73, 0x9c, 0x02, 0x08, 0x6b, 0x2f, 0x52, 0x1a, 0x91, 0x44, 0x36, 0x76,
	0xd8, 0x7f, 0xd2, 0x10, 0xfb, 0x98, 0xe3, 0xb1, 0x58, 0x15, 0x89, 0xf3, 0xda, 0x96, 0x8e, 0x2e,
	0x9d, 0xdc, 0x4c, 0xbc, 0xe1, 0xda, 0x8f, 0xa1, 0x1d, 0xb2, 0x98, 0x13, 0x16, 0x63, 0xc7, 0xd8,
	0xc1, 0x0b, 0x7d, 0x06, 0x3a, 0x66, 0x97, 0x85, 0xd3, 0x91, 0xb9, 0x9c, 0xb5, 0xc0, 0xaf, 0x5f,
	0xb6, 0x59, 0x88, 0x13, 0xcc, 0xd0, 0x09, 0x18, 0x89, 0x30, 0xa9, 0x63, 0xca, 0x4c, 0xa8, 0x71,
	0x68, 0x65, 0xdf, 0x13, 0x30, 0xa8, 0xf0, 0x94, 0xd3, 0x92, 0xb9, 0xd0, 0xdb, 0x6e, 0x13, 0x25,
	0x5d, 0x32, 0x5a, 0xe6, 0x71, 0x76, 0xe9, 0xb4, 0xa5, 0xea, 0x9e, 0x92, 0x9e, 0xc3, 0xd1, 0x5a,
	0xb4, 0xa8, 0x1b, 0xb0, 0x76, 0x5d, 0xf8, 0xef, 0x2a, 0x98, 0xa3, 0xac, 0x20, 0x8c, 0x6f, 0x61,
	0x57, 0xfe, 0x0d, 0x76, 0xf5, 0x9d, 0xd8, 0x9f, 0x35, 0xb0, 0x57, 0x03, 0xe4, 0xbd, 0xed, 0xc4,
	0x62, 0x12, 0x7d, 0x0e, 0x1a, 0xa3, 0xd7, 0xab, 0x8b, 0x69, 0xbe, 0x6e, 0x55, 0x8d, 0x9e, 0xb0,
	0x65, 0x34, 0xa5, 0xd7, 0x35, 0x78, 0xe3, 0xdd, 0xe0, 0x8f, 0x9f, 0x43, 0xbb, 0xde, 0xd3, 0x05,
	0x63, 0x19, 0x93, 0x24, 0x72, 0x94, 0x1d, 0xec, 0xdc, 0x3f, 0x55, 0x30, 0x2b, 0xff, 0xff, 0x7f,
	0x26, 0xdc, 0xf4, 0x95, 0xbe, 0xcf, 0x57, 0xed, 0x87, 0xfa, 0xca, 0xd8, 0xef, 0x2b, 0x73, 0xa7,
	0xaf, 0xbe, 0xda, 0x9c, 0x29, 0xad, 0x7b, 0xe8, 0x6f, 0xcd, 0x14, 0xf7, 0x6f, 0x05, 0x4c, 0x9f,
	0x24, 0xe4, 0x2d, 0x4e, 0xff, 0xa1, 0x6b, 0x36, 0x39, 0x69, 0xfb, 0x38, 0x99, 0x0f, 0xe5, 0xa4,
	0xef, 0xe7, 0x64, 0xec, 0xe2, 0x74, 0xfa, 0x09, 0x58, 0x77, 0xf5, 0x1d, 0x40, 0xdb, 0xbf, 0x18,
	0xbe, 0x1e, 0x07, 0xe7, 0x62, 0x42, 0x5a, 0x60, 0xcc, 0x07, 0xaf, 0xce, 0x02, 0x5b, 0x7d, 0xf5,
	0x29, 0x3c, 0x0d, 0x69, 0xea, 0xc9, 0xef, 0xae, 0x17, 0xbe, 0xa9, 0xfe, 0xdc, 0x54, 0x9f, 0xdd,
	0x9f, 0xca, 0xe5, 0x0f, 0x86, 0xfc, 0xf7, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x07, 0x7e, 0x45,
	0xc8, 0xcc, 0x07, 0x00, 0x00,
}
